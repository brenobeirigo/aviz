<!DOCTYPE html>
<html>
    <head>
        <meta charset='utf-8' />
        <title>Draw GeoJSON points</title>
        <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
        
        <script src='https://api.mapbox.com/mapbox-gl-js/v0.52.0/mapbox-gl.js'></script>
        <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v2.0.0/turf.min.js' charset='utf-8'></script>
        <link href='https://api.mapbox.com/mapbox-gl-js/v0.52.0/mapbox-gl.css' rel='stylesheet' />
        <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.52.0/mapbox-gl.css' rel='stylesheet' />
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <nav id="menu"></nav>
        <div id="map"></div>
        <script src='http://d3js.org/d3.v3.min.js' charset='utf-8'></script>

        <script>
            //var slider = document.getElementById("myRange");
            //var output = document.getElementById("demo");
            //output.innerHTML = slider.value; // Display the default slider value

            mapboxgl.accessToken = 'pk.eyJ1IjoiYnJlbm9iZWlyaWdvIiwiYSI6ImNpeHJiMDNidTAwMm0zNHFpcXVzd2UycHgifQ.tWIDAiRhjSzp1Bd40rxaHw';

            var map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/brenobeirigo/cjrjc79t00a3s2so32n11zu6b',
                zoom: 0,
                center: [-74.000123, 40.730431],
                pitch: 60, // pitch in degrees
                bearing: -60 // bearing in degrees
            });

            var acceleration = 50;

            /*


            // Update the current slider value (each time you drag the slider handle)
            var output = document.getElementById("month");
            var slider = document.getElementById("slider");
            output.innerHTML = acceleration;
            slider.value = acceleration;

            document.getElementById('slider').addEventListener('input', function(e) {
            acceleration = parseInt(e.target.value, 10);
            output.innerHTML = acceleration;
            });
            */


            //var source_gson = 'all.geojson';
            //var source_gson2 = 'all2.geojson';
            var source_gson = '2v.json';

            //var source_gson = 'http://localhost:2999/traces/V1.geojson';
            //var source_gson = 'http://localhost:3000/traces/week_capacity10.geojson';
            
            map.on('load', function () {

                var geojsonTraces = {
                    "name": "NewFeatureType",
                    "type": "FeatureCollection",
                    "features": []
                };

                var geojsonNodes = {
                    "name": "NewFeatureType",
                    "type": "FeatureCollection",
                    "features": []
                };

                // on a regular basis, add more coordinates from the saved list and update the map
                var speed = 1000;


                // A single point that animates along the route.
                // Coordinates are initially set to origin.
                var point = {
                    "type": "FeatureCollection",
                    "features": []
                };

                function animatePoint(id, previous, current, next) {
                    console.log(id + " - " + previous + " - " + current + " - " + next + " - " + point.features[id])
                    // Update point geometry to a new position based on counter denoting
                    // the index to access the arc.
                    point.features[id].geometry.coordinates = current;

                    // Calculate the bearing to ensure the icon is rotated to match the route arc
                    // The bearing is calculate between the current point and the next point, except
                    // at the end of the arc use the previous point and the current point
                    point.features[id].properties.bearing = turf.bearing(
                        turf.point(previous),
                        turf.point(next)
                    );
                    console.log(point.features[id]);
                }
                


                // We use D3 to fetch the JSON here so that we can parse and use it separately
                // from GL JS's use in the added source. You can use any request method (library
                // or otherwise) that you want.
                
                class Trace{
                    constructor(traces){
                        this.traces = traces;
                        this.coordinates = traces.geometry.coordinates;                        
                    }
                }

                class TraceRebalancing extends Trace{
                    constructor(traces){
                        super(traces);
                        let o = traces.geometry.coordinates[0];
                        let d = traces.geometry.coordinates[traces.geometry.coordinates.length - 1];
                        this.od = {
                            "geometry": {
                                "type":"LineString",
                                "coordinates": [o,d]
                            },
                            "type":"Feature",
                            "properties": {
                                "to": "target"
                            }

                        };
                    }

                    get o(){
                        return this.od.geometry.coordinates[0];
                    }

                    get d(){
                        return this.od.geometry.coordinates[1];
                    }

                    set o(newOrigin){
                        this.od.geometry.coordinates[0] = newOrigin;
                    }
                }

                class Vehicle{
                    constructor(id, geojson){
                        this.id = id,
                        this.route = geojson.features;
                        this.leg = 0;
                        this.firstLocation = this.getCoordinate(this.leg, 0);
                        this.previous = this.firstLocation;
                        this.current = this.previous;
                        this.next = this.current;
                        this.i = 0;
                        this.isRebalancing = false;
                        this.relocatingIndex = 0;
                        this.rebOrigin = null;
                        this.targetNode = null;
                        this.nodes = [];
                        this.paths = [];
                        this.currentTrace = null;
                        this.curretPath = null;
                    }

                    isFeaturePoint() {
                        return this.route[this.leg].geometry.type == "Point";
                    }
                    getNextNode(){
                        return (this.leg + 2 < this.route.length? this.route[this.leg + 2]:null);
                    }
                    nextNodeIsTarget(){
                        return this.leg + 2 < this.route.length && this.route[this.leg + 2].properties.type == "target";
                    }
                    getCurrentNode(){
                        return this.route[this.leg];
                    }
                    processNode(){
                        var node = this.getCurrentNode();
                        var nextNode = this.getNextNode();

                        // Add point if it is not a stop point
                        if (node.properties.type != "stop") {
                            this.nodes.push(node);
                        }
                        // Update target node
                        if (this.nextNodeIsTarget()) {
                            
                            this.nodes.push(nextNode);

                            var rebalancingLine = this.route[this.leg + 1];
                            this.currentTrace = new TraceRebalancing(rebalancingLine);
                            this.paths.push(this.currentTrace.od);

                            this.isRebalancing = true;

                            this.targetNode = this.nodes[this.nodes.length - 1];
                            this.rebOrigin = this.paths[this.paths.length - 1];
                            this.i = 0;
                            // go to next feature (skip rebalancing path and target)
                            this.leg += 3;

                    
                        } else {
                            this.i = 0;
                            // go to next feature (skip)
                            this.leg++;
                        }
                    }

                    processTrace(){
                        var path = this.route[this.leg];
                        
                        if (this.i == 0) {
                            this.currentPath = path.geometry.coordinates;
                            path.geometry.coordinates = [];
                            //console.log("path:" + path.geometry.coordinates.length + "current:" + this.currentPath.length);
                            this.paths.push(path);
                        }

                        // Feature is a line. Show step by step.
                        var coordinates = this.currentPath;
                        var load = path.properties.load;
                        var duration = path.properties.distance_s;
                        var capacity = path.properties.capacity;
                        duration = parseInt(duration, 10);

                        if (this.i < coordinates.length) {
                            //console.log("coord:" + coordinates.length + " - Coordinates:" + path.geometry.coordinates.length + " - i:" + this.i);

                            this.next = this.i < coordinates.length - 1 ? coordinates[this.i + 1] : this.current;

                            this.updateCurrentPosition();
                            this.updateBearing();
                            this.addCoordinatesToPath(coordinates[this.i]);
                            this.previous = this.current;
                            
                            if (this.isRebalancing) {
                                this.updateRelocationGuideLineOrigin(coordinates[this.i]);
                            }
                            
                            //map.panTo(coordinates[i]);
                            this.i++;
                            this.current = this.i < coordinates.length ? coordinates[this.i] : this.current;

                        } else {
                            // End processing line, can go to next feature
                            this.i = 0;
                            this.leg++;

                            if (this.isRebalancing) {
                                this.stopRelocating();
                            }
                        }
                    }

                    updateCurrentPosition(){
                        point.features[this.id].geometry.coordinates = this.current;
                    }

                    addCoordinatesToPath(coords){
                        this.paths[this.paths.length - 1].geometry.coordinates.push(coords);
                    }

                    updateBearing(){
                        point.features[this.id].properties.bearing = turf.bearing(
                            turf.point(this.previous),
                            turf.point(this.next)
                        );
                    }

                    updateRelocationGuideLineOrigin(o){
                        //Updating the line origin when rebalancing
                        this.currentTrace.o = o;
                    }
                    
                    stopRelocating(){
                        // Remove relocation path and target
                        this.paths.splice(this.paths.length - 2, 1);
                        this.nodes.splice(this.nodes.length - 1, 1);
                        this.isRebalancing = false;
                    }

                    update(timer){

                        if (this.leg < this.route.length) {

                            if (this.isFeaturePoint()) {
                                this.processNode();
                            } else {
                                this.processTrace();
                            }
                        } else {
                            //Stop when all features are processed
                            window.clearInterval(timer);
                        }
                    }

                    getCoordinate(f, i) {
                        if (this.isFeaturePoint(f)) {
                            return this.route[f].geometry.coordinates;
                        } else {
                            return this.route[f].geometry.coordinates[i];
                        }
                    }
                }

                function getVehicleListFromData(data){
                    
                    fleet = [];

                    for (vehicle of data["routes"]) {
                        fleet.push(new Vehicle(vehicle["id"], vehicle["path"]));
                    }

                    fleet.pop();

                    return fleet;

                }
                d3.json(source_gson, function(err, data) {

                    fleet = getVehicleListFromData(data);

                    console.log(fleet);

                    if (err) throw err;
                    
                    // add it to the map
                    map.addSource('trace', { type: 'geojson', data: geojsonTraces });
                    map.addSource('nodes', { type: 'geojson', data: geojsonNodes });
                    
                    var minLineWidth = 2;
                    var maxLineWidth = 7;

                    var minLineOpacity = 0.2;
                    var maxLineOpacity = 0.8;
                    
                    //TODO what happens when we have target -> target?

                    // Vehicle route
                    map.addLayer({
                        "id": "trace",
                        "type": "line",
                        "source": "trace",
                        "layout": {
                            "line-join": "round",
                            "line-cap": "round"
                            },
                        "paint": {
                        "line-color":
                            [
                                'case',
                                ["==",  ['get', 'to'], "target"], 
                                "#FF0000", "#FF0000"
                            ], 
                            "line-opacity":[
                                'case',
                                ["==",
                                    ['get', 'to'],
                                    "target"
                                ], 
                                minLineOpacity, 
                                [
                                '+', 
                                    ['*',
                                        ['/', 
                                            ['get', 'load'],
                                            ['get', 'capacity']
                                        ],
                                        maxLineOpacity - minLineOpacity
                                    ],
                                    minLineOpacity
                                ]
                            ],
                        "line-width": [
                            'case',
                                ["==",
                                    ['get', 'to'],
                                    "target"
                                ], 
                                maxLineWidth,[
                                    'case',
                                        ["==",
                                            ['get', 'load'],
                                            0
                                        ], 
                                    0, 
                                    [
                                    '+', 
                                        ['*',
                                            ['/', 
                                                ['get', 'number_of_requests'],
                                                ['get', 'capacity']
                                            ],
                                            maxLineWidth-minLineWidth
                                        ],
                                        minLineWidth
                                    ]
                                ]
                            ]
                        }}
                    );

                    var minPointSize = 4;
                    var maxPointSize = 8;
                    var targetCircleRadius = 40;
                    var targetCircleOpacity = 0.3;
                    var targetCircleColor = '#FF0000';

                    var rangePointSize = maxPointSize - minPointSize;
                    var pointStyle = {
                        radius: {
                            origin:10,
                            pickup:minPointSize,
                            destination:maxPointSize,
                            target:targetCircleRadius,
                            stop: 10,
                            middle:maxPointSize
                            },
                        color: {
                            business: {light:"#fcc777", dark:"#f8a51b"},
                            standard: {light:"#bd7cb4", dark:"#a3218e"},
                            lowcost: {light:"#56c4c5", dark:"#00acac"}
                        }
                    };

                    // Layer containing the customer ODs
                    map.addLayer({
                        "id": "nodes",
                        "type": "circle",
                        "source": "nodes",
                        "paint": {
                        "circle-radius": [
                            'match',
                            ['get', 'type'],
                            'origin', pointStyle.radius.origin,
                            'pickup', pointStyle.radius.pickup,
                            'destination', pointStyle.radius.destination,
                            'target', pointStyle.radius.target,
                            'stop', pointStyle.radius.stop,
                            'middle', pointStyle.radius.middle,
                            /* other */ 6
                        ],
                        'circle-opacity': [
                            'match',
                            ['get', 'type'],
                            'target', targetCircleOpacity,
                            'pickup', 1,
                            'destination',0.5,
                            /* other */ 0.5],
                        'circle-color': [
                            'match',
                            ['get', 'type'],
                            'origin', '#FFFFFF',
                            'pickup',  [
                                'match',
                                ['get', 'user_class'],
                                'A', pointStyle.color.business.dark,
                                'B', pointStyle.color.standard.dark,
                                'C', pointStyle.color.lowcost.dark,
                                /* other */ '#00ff00'],
                            'destination', [
                                'match',
                                ['get', 'user_class'],
                                'A', pointStyle.color.business.dark,
                                'B', pointStyle.color.standard.dark,
                                'C', pointStyle.color.lowcost.dark,
                                /* other */ '#00ff00'],
                            'target', targetCircleColor,
                            'stop', '#FF0000',
                            'middle', '#FF0000',
                            /* other */ '#ccc'
                        ]
                        }
                    });

                    for(v of fleet){
                        let f = {
                            "type": "Feature",
                            "properties": { "id": v.id, "status": "rebalancing" },
                            "geometry": {
                                "type": "Point",
                                "coordinates": v.firstLocation
                            }
                        };
                        point.features.push(f);
                    }

                    // add it to the map
                    map.addSource('point', { type: 'geojson', data: point});
         
                    // Adding red arrow representing vehicle
                    map.loadImage('img/red_arrow_up.png', function(error, image) {
                        if (error) throw error;
                        map.addImage('vehicle', image,  { 'sdf': true });
                        map.addLayer({
                            "id": "point",
                            "type": "symbol",
                            "source":  "point",
                            "layout": {
                                "icon-image": "vehicle",
                                "icon-size": 1.0,
                                "icon-rotate": ["get", "bearing"],
                                "icon-rotation-alignment": "map",
                                "icon-allow-overlap": true,
                                "icon-ignore-placement": true
                            },
                            'paint': {
                                'icon-color': [
                                    'match', // Use the 'match' expression: https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions-match
                                    ['get', 'status'], // Use the result 'STORE_TYPE' property
                                    'rebalancing', '#FF0000',
                                    'carrying', '#00FF00',
                                    'parked', '#0000FF',
                                    '#FFFFFF' // any other store type
                                ]
                            }
                        });
                    });

                    class Node{
                        constructor(node){
                            this.type = node.properties.type;    
                            this.arrival = node.properties.arrival;
                            this.departure = node.properties.departure;
                            this.earliest = node.properties.earliest;
                            this.latest = node.properties.latest;
                            this.userId = node.properties.user_id;
                            this.networkId = node.properties.network_id;
                            this.nodeId = node.properties.id;
                            this.load = node.properties.load;
                        }

                        get popup(){
                            let str = "";
                            str += "<h3>" + this.userId + "</h3>";
                            str += "<h4><table><tr>";
                            str += "<td align='right'><b>Placement:</b></td> <td>" + this.earliest + "</br></td></tr><tr>";
                            str += "<td align='right'><b>Arrival:</b></td> <td>" + this.arrival + "</br></td></tr><tr>";
                            str += "<td align='right'><b>Latest:</b></td> <td>" + this.latest + "</br></td></tr><tr>";
                            str += "<td align='right'><b>Type:</b></td> <td>" + this.type + "</br></td></tr><tr>";
                            str += "<td align='right'><b>Node id:</b></td> <td>" + this.nodeId + "</td>";
                            str += "</tr></table></h4>";
                            return str;
                        }
                    }

                    class NodeMiddle extends Node{
                        constructor(node){
                            super(node);
                        }
                        get popup() {
                            let str = "";
                            str += "<h3>New assignment</h3>";
                            str += "<h4><table><tr>";
                            str += "<td align='right'><b>Arrival:</b></td> <td>" + this.arrival + "</br></td></tr><tr>";
                            str += "<td align='right'><b>Type:</b></td> <td>" + this.type + "</br></td></tr><tr>";
                            str += "<td align='right'><b>Node id:</b></td> <td>" + this.nodeId + "</td>";
                            str += "</tr></table></h4>";
                            return str;
                        }
                    }


                    class NodeFactory {
                        constructor(node) {
                            if (node.properties.type === "middle") {
                                return new NodeMiddle(node);
                            } else {
                                return new Node(node);
                            }
                        }
                    }

                    // Change the cursor to a pointer when the mouse is over the nodes layer
                    map.on('mouseenter', 'nodes', function () {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    
                    // Change it back to a pointer when it leaves
                    map.on('mouseleave', 'nodes', function () {
                        map.getCanvas().style.cursor = '';
                    });

                    map.on('click', function(e) {

                        var features = map.queryRenderedFeatures(e.point, {
                            layers: ['nodes'] // replace this with the name of the layer
                        });

                        if (!features.length) {
                            return;
                        }

                        var feature = features[0];

                        var node = new NodeFactory(feature);

                        var popup = new mapboxgl.Popup({ offset: [0, -15] })
                            .setLngLat(feature.geometry.coordinates)
                            .setHTML(node.popup)
                            .addTo(map);
                    });

                    // setup the viewport
                    map.jumpTo({ 'center': fleet[0].firstLocation, 'zoom': 13 });
                    map.setPitch(30);
                    
                    var timer = window.setInterval(function() {
                        let paths = [];
                        let nodes = [];
                        for (v of fleet){
                            v.update(timer);
                            Array.prototype.push.apply(paths, v.paths);
                            Array.prototype.push.apply(nodes, v.nodes);
                        }
                        geojsonTraces.features = paths;
                        geojsonNodes.features = nodes;
                        map.getSource('trace').setData(geojsonTraces);
                        map.getSource('nodes').setData(geojsonNodes);
                        // Update the source with this new data.
                        map.getSource('point').setData(point);

                    }, speed/acceleration);
                });

            var toggleableLayerIds = [ 'trace', 'nodes' ];
            
            for (var i = 0; i < toggleableLayerIds.length; i++) {
                var id = toggleableLayerIds[i];

                var link = document.createElement('a');
                link.href = '#';
                link.className = 'active';
                link.textContent = id;
                
                link.onclick = function (e) {
                    var clickedLayer = this.textContent;
                    e.preventDefault();
                    e.stopPropagation();
                    
                    var visibility = map.getLayoutProperty(clickedLayer, 'visibility');
                    
                    if (visibility === 'visible') {
                        map.setLayoutProperty(clickedLayer, 'visibility', 'none');
                        this.className = '';
                    } else {
                        this.className = 'active';
                        map.setLayoutProperty(clickedLayer, 'visibility', 'visible');
                    }
                };
                
                var layers = document.getElementById('menu');
                layers.appendChild(link);
            }
            });

        </script>
    
    </body>
</html>