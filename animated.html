<!DOCTYPE html>
<html>
    <head>
        <meta charset='utf-8' />
        <title>Draw GeoJSON points</title>
        <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
        
        <script src='https://api.mapbox.com/mapbox-gl-js/v0.52.0/mapbox-gl.js'></script>
        <script src='https://unpkg.com/@turf/turf/turf.min.js' charset='utf-8'></script>
        <link href='https://api.mapbox.com/mapbox-gl-js/v0.52.0/mapbox-gl.css' rel='stylesheet' />
        <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.52.0/mapbox-gl.css' rel='stylesheet' />
        <link rel="stylesheet" href="styles.css">
        <!-- Font Awesome -->
        <link href="https://use.fontawesome.com/releases/v5.8.2/css/all.css" rel="stylesheet" />
        <!-- Google Fonts -->
        <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet" />
        <!-- MDB -->
        <link href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/2.2.1/mdb.min.css" rel="stylesheet" />
    </head>
    <body>
        <nav id="menu">


        </nav>
        <nav id="slider">
            <label class="form-label" for="customRange1">Example range</label>
            <div class="range">
                <input type="range" class="form-range" id="customRange1"/>
            </div>
        </nav>
        <div id="map"></div>
        <script src='http://d3js.org/d3.v3.min.js' charset='utf-8'></script>

        <script>
            //var slider = document.getElementById("myRange");
            //var output = document.getElementById("demo");
            //output.innerHTML = slider.value; // Display the default slider value

            mapboxgl.accessToken = 'pk.eyJ1IjoiYnJlbm9iZWlyaWdvIiwiYSI6ImNpeHJiMDNidTAwMm0zNHFpcXVzd2UycHgifQ.tWIDAiRhjSzp1Bd40rxaHw';
            var allCoords = [];
            var map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/brenobeirigo/cjrjc79t00a3s2so32n11zu6b',
                zoom: 0,
                center: [-74.000123, 40.730431],
                pitch: 60, // pitch in degrees
                bearing: -60 // bearing in degrees
            });

            var acceleration = 50;

            /*


            // Update the current slider value (each time you drag the slider handle)
            var output = document.getElementById("month");
            var slider = document.getElementById("slider");
            output.innerHTML = acceleration;
            slider.value = acceleration;

            document.getElementById('slider').addEventListener('input', function(e) {
            acceleration = parseInt(e.target.value, 10);
            output.innerHTML = acceleration;
            });
            */


            //var source_gson = 'all.geojson';
            //var source_gson2 = 'all2.geojson';
            //var source_gson = '2v.json';
            var source_gson = 'fleetJourney.json';

            //var source_gson = 'http://localhost:2999/route/V1.geojson';
            //var source_gson = 'http://localhost:3000/route/week_capacity10.geojson';
            
            map.on('load', function () {

                var geojsonRoutes = {
                    "name": "NewFeatureType",
                    "type": "FeatureCollection",
                    "features": []
                };

                var geojsonNodes = {
                    "name": "NewFeatureType",
                    "type": "FeatureCollection",
                    "features": []
                };

                // on a regular basis, add more coordinates from the saved list and update the map
                var speed = 1000;


                // A single geojsonVehicles that animates along the route.
                // Coordinates are initially set to origin.
                var geojsonVehicles = {
                    "type": "FeatureCollection",
                    "features": []
                };

                // We use D3 to fetch the JSON here so that we can parse and use it separately
                // from GL JS's use in the added source. You can use any request method (library
                // or otherwise) that you want.

                function splitLineString(coordinates, rects){
                    let line = turf.lineString(coordinates);
                    let lineDistance = turf.lineDistance(line);
                    let segments = lineDistance / rects;

                    let rectCollection = [];
                    for (let i = 0; i <= rects; i++) {
                        let pointOnLine = turf.along(line, i * segments);
                        rectCollection.push(pointOnLine.geometry.coordinates);
                    }

                    console.log("N. coordinates: " + rectCollection.length + " - segments: " + segments + " - rects: " + rects);


                    return rectCollection;
                }
                
                class Route{
                    constructor(lineString){
                        this.lineString = lineString;
                        this.traveled = lineString;
                        this.fromPoint = this.lineString.properties.from;
                        this.toPoint = this.lineString.properties.to;
                        this.coordinates = this.lineString.geometry.coordinates;
                        //console.log(this.coordinates);
                        this.duration = this.lineString.properties.distance_s;
                        // this.coordinates = splitLineString(this.coordinates, this.duration)
                        //console.log(this.coordinates);
                        
                        
                        //console.log("A)" + this.toString() + ":" + this.coordinates.length + " - " +
                        //    this.traveled.geometry.coordinates.length + " - " +
                        //    this.lineString.geometry.coordinates.length
                        //)

                        //this.traveled.geometry.coordinates = [];

                        //console.log("B)" + this.toString() + ":" + this.coordinates.length + " - " +
                        //  this.traveled.geometry.coordinates.length + " - " +
                        //    this.lineString.geometry.coordinates.length
                        //)

                        this.indexCurrentCoord = 0;                    
                    }
                    
                    get type(){
                        if (this.fromPoint == "pickup" && this.toPoint == "to"){
                            return "carrying";
                        }
                        
                    }
                    get progress(){
                        let cur = this.indexCurrentCoord + 1;
                        let total = this.coordinates.length;
                        return  parseFloat(cur / total);
                    }
                    toString(){
                        let cur = this.indexCurrentCoord + 1;
                        let total = this.coordinates.length;
                        let progress = this.progress.toFixed(2) + "%";
                        return "Route["+ cur + "/" + total + "]" + "("+progress+") - " + this.fromPoint + " - " + this.toPoint;
                    }

                    isActive(){
                        return this.indexCurrentCoord < this.coordinates.length;
                    }

                    getCurrentCoordinate(){
                        return this.coordinates[this.indexCurrentCoord];
                    }
                }

                class RouteRebalancing extends Route{
                    constructor(route){
                        super(route);
                        let o = route.geometry.coordinates[0];
                        let d = route.geometry.coordinates[route.geometry.coordinates.length - 1];
                        this.od = {
                            "geometry": {
                                "type":"LineString",
                                "coordinates": [o,d]
                            },
                            "type":"Feature",
                            "properties": {
                                "to": "target"
                            }

                        };
                    }

                    
                    toString() {
                        return "RouteRebalancing(" + this.coordinates.length + ")";
                    }

                    get o(){
                        return this.od.geometry.coordinates[0];
                    }

                    get d(){
                        return this.od.geometry.coordinates[1];
                    }

                    set o(newOrigin){
                        this.od.geometry.coordinates[0] = newOrigin;
                    }
                }

                class FeatureList {
                    constructor(geojson) {
                        this.features = geojson.features;
                        this.leg = 0;
                        this.preProcess();
                    }

                    preProcess(){
                        for (let f of this.features){
                            if (f.geometry.type === "LineString"){
                                f.geometry.coordinates = splitLineString(f.geometry.coordinates, f.properties.distance_s);
                            }
                        }
                    }

                    get progress(){

                        if (this.isEmpty()) {
                            return 1;
                        }
                        
                        let total = this.features.length;
                        let cur = this.leg + 1;
                        return parseFloat(cur / total)
                    }

                    toString() {
                        let total = this.features.length;

                        if (this.isEmpty()){
                            return "Finished processing" + total + " features"
                        }
                        let cur = this.leg + 1;
                        let progress = this.progress.toFixed(2) + "%";
                        return this.type +  "[" + cur + "/" + total + "]" + "(" + progress + ")";
                    }

                    get type(){
                        return this.current.geometry.type;
                    }

                    getAllCoordinates(){
                        let coords = [];

                        for(let f of this.features){
                            
                            if(f.geometry.type == "Point"){
                                let node = new NodeFactory(f); 
                                if (!(node instanceof NodeTarget)){
                                    Array.prototype.push.apply(coords,[node.coordinates]);
                                }
                                
                            }else{
                                let route = new RouteFactory(f);
                                Array.prototype.push.apply(coords, route.coordinates);
                            }

                        }

                        return coords;
                    }


                    isPoint() {
                        return this.current.geometry.type == "Point";
                    }

                    isLineString() {
                        return this.current.geometry.type == "LineString";
                    }

                    get current() {
                        return this.features[this.leg];
                    }

                    currentPath() {
                        return this.features[this.leg + 1];
                    }


                    isEmpty(){
                        return this.leg >= this.features.length;
                    }

                    increment() {
                        this.leg++;
                        // this.leg = Math.min(++this.leg, this.features.length-1);
                    }
                }

                function getDateDiffInSeconds(earliest, latest){
                    earliest = new Date(earliest.replace(/-/g, '/'));
                    latest = new Date(latest.replace(/-/g, '/'));
                    return parseInt((latest - earliest)/1000)
                
                }

                class Node {
                    constructor(node) {
                        this.feature = node;
                        this.type = node.properties.type;
                        this.arrival = node.properties.arrival;
                        this.departure = node.properties.departure;
                        this.totalWaitingAtPointInSecs = getDateDiffInSeconds(this.arrival, this.departure);
                        this.elapsedTimeAtPointInSecs = 0;
                        this.earliest = node.properties.earliest;
                        this.latest = node.properties.latest;
                        this.userId = node.properties.user_id;
                        this.networkId = node.properties.network_id;
                        this.nodeId = node.properties.id;
                        this.nPassengers = node.properties.n_passengers;
                        this.coordinates = node.geometry.coordinates;
                    }

                    isActive(){
                        return this.elapsedTimeAtPointInSecs < this.totalWaitingAtPointInSecs;
                    }

                    incrementElapsed(){
                        this.elapsedTimeAtPointInSecs++;
                    }

                    get popup() {
                        let str = "";
                        str += "<h3>" + this.userId + "</h3>";
                        str += "<h4><table><tr>";
                        str += "<td align='right'><b>Placement:</b></td> <td>" + this.earliest + "</br></td></tr><tr>";
                        str += "<td align='right'><b>Arrival:</b></td> <td>" + this.arrival + "</br></td></tr><tr>";
                        str += "<td align='right'><b>Departure:</b></td> <td>" + this.departure + "</br></td></tr><tr>";
                        str += "<td align='right'><b>Latest:</b></td> <td>" + this.latest + "</br></td></tr><tr>";
                        str += "<td align='right'><b>Duration:</b></td> <td>" + this.totalWaitingAtPointInSecs + "</br></td></tr><tr>";
                        str += "<td align='right'><b>Type:</b></td> <td>" + this.type + "</br></td></tr><tr>";
                        str += "<td align='right'><b>Node id:</b></td> <td>" + this.nodeId + "</td>";
                        str += "</tr></table></h4>";
                        return str;
                    }
                }

                class NodeOrigin extends Node {
                    constructor(node) {
                        super(node);
                    }
                }

                class NodeTarget extends Node {
                    constructor(node) {
                        super(node);
                    }
                }

                class NodePickup extends Node {
                    constructor(node) {
                        super(node);
                    }
                }

                class NodeTo extends Node {
                    constructor(node) {
                        super(node);
                    }
                }

                class NodeStop extends Node {
                    constructor(node) {
                        super(node);
                    }
                }

                class NodeMiddle extends Node {
                    constructor(node) {
                        super(node);
                    }
                    get popup() {
                        let str = "";
                        str += "<h3>New assignment</h3>";
                        str += "<h4><table><tr>";
                        str += "<td align='right'><b>Arrival:</b></td> <td>" + this.arrival + "</br></td></tr><tr>";
                        str += "<td align='right'><b>Type:</b></td> <td>" + this.type + "</br></td></tr><tr>";
                        str += "<td align='right'><b>Node id:</b></td> <td>" + this.nodeId + "</td>";
                        str += "</tr></table></h4>";
                        return str;
                    }
                }

                class NodeFactory {
                    constructor(node) {
                        if (node.properties.type === "middle") {
                            return new NodeMiddle(node);
                        } else if (node.properties.type === "origin") {
                            return new NodeOrigin(node);
                        } else if (node.properties.type === "target") {
                            return new NodeTarget(node);
                        } else if (node.properties.type === "pickup") {
                            return new NodePickup(node);
                        } else if (node.properties.type === "to") {
                            return new NodeTo(node);
                        } else if (node.properties.type === "stop") {
                            return new NodeStop(node);
                        } else {
                            return new Node(node);
                        }
                    }
                }

                class RouteFactory {
                    constructor(route) {
                        if (route.properties.to === "target") {
                            return new RouteRebalancing(route);
                        } else {
                            return new Route(route);
                        }
                    }
                }

                class Journey {
                    constructor(geojson){
                        this.features = new FeatureList(geojson);
                        this.origin = new NodeFactory(this.features.current);
                        this.currentPoint = this.origin;
                        

                        // Coordinate - previous, current, next used to calculate bearing
                        this.previousCoordinate = this.currentPoint.coordinates;
                        this.currentCoordinate = this.currentPoint.coordinates;

                        this.plannedPoints = [];
                        this.plannedLineString = [];

                        this.visitedPoints = [];
                        this.traveledLineString = [];
                        this.coords = [];
                        this.currentRoute = null;

                        // Plannned route refers to the route vehicle was following
                        // before waypoint was found
                        this.plannedRoute = null;
                    }

                    getPassengers(){
                        this.currentPoint.nPassengers;
                    }

                    alreadyVisitedCurrentPoint(){
                        let lastVisitedPointFeature = this.visitedPoints[this.visitedPoints.length - 1]

                        return this.visitedPoints.length > 0 && this.features.current === lastVisitedPointFeature
                    }

                    endCurrentRoute(){
                        this.currentRoute = null;
                        this.plannedRoute = null;
                    }

                    updateCurrentCoordinate(){
                        this.previousCoordinate = this.currentCoordinate;
                        this.currentRoute.indexCurrentCoord++;
                        this.currentCoordinate = this.currentRoute.isActive() ? this.getCurrentCoordinate() : this.currentCoordinate;

                    }

                    getCurrentCoordinate(){
                        return this.currentRoute.getCurrentCoordinate();
                    }

                    addLineString(lineString) {
                        this.traveledLineString.push(lineString);
                    }
                    
                    addPlannedLineString(lineString) {
                        this.plannedLineString.push(lineString);
                    }

                    addFeaturePoint(point) {
                        // Add point if it is not a stop point
                        if (point.properties.type !== "stop") {

                            if (point.properties.type === "target"){
                                this.plannedPoints.push(point);
                            }else {
                                this.currentPoint = new NodeFactory(point);
                                this.visitedPoints.push(point);
                            }
                        }
                    }

                    addCoords(coords){
                        this.coords.push(coords);
                        this.traveledLineString[this.traveledLineString.length - 1].geometry.coordinates.push(coords);
                    }

                    removeRebalancingGuideLine(){
                        this.plannedLineString = [];
                        this.plannedPoints = [];
                    }

                    addRouteFromLineString(feature){
                        let route = new RouteFactory(feature);
                        if (route instanceof RouteRebalancing){
                            this.plannedRoute = route;
                            this.addPlannedLineString(this.plannedRoute.od);
                        }else{
                            this.currentRoute = route;
                            this.currentRoute.traveled.geometry.coordinates = [];
                            this.addLineString(this.currentRoute.traveled);
                        }
                        return route;
                    }
                }

                class Vehicle{
                    constructor(id, geojson){
                        this.id = id;
                        this.status = "idle";
                        this.isRebalancing = false;
                        this.journey = new Journey(geojson);
                    }

                    hasFinishedJourney(){
                        return this.journey.features.isEmpty();
                    }

                    toString(){
                        return "Vehicle " + this.id;
                    }

                    get origin(){
                        return this.journey.origin;
                    }

                    get bearing(){
                        return turf.bearing(
                            turf.point(this.journey.previousCoordinate),
                            turf.point(this.journey.currentCoordinate)
                        );
                    }

                    get currentPoint(){
                        return this.journey.features.current;
                    }

                    get currentLineString(){
                        return this.journey.features.getLineString();
                    }

                    get nPassengers(){
                        return this.journey.currentPoint.nPassengers;
                    }

                    currentStatus(){
                        if (this.nPassengers > 0){
                            return "carrying"+ this.nPassengers;
                        } else if (this.nPassengers == 0){
                            if (this.journey.currentRoute !== null){
                                if (this.journey.currentRoute.toPoint == "pickup"){
                                    return "cruising";
                                }
                                else {
                                    return "rebalancing";
                                }
                            } else {
                                return "idle";
                            }
                        }
                    }

                    processNode(){

                        if (!this.journey.alreadyVisitedCurrentPoint()){
                            this.journey.addFeaturePoint(this.journey.features.current);
                        }

                        if (this.journey.currentPoint.isActive()) {
                            this.journey.currentPoint.incrementElapsed();
                        } else {
                            this.journey.features.increment();
                        }
                        

                    }
                    
                    // i = 0 - Node(stop)
                    // i = 1 - Route(stop-target) - rebalancing
                    // i = 2 - Node(target)
                    // i = 3 - Route(stop-middle)
                    // i = 4 - Node(middle)
                    // i = 5 - Route(middle - Pickup)
                    processRoute(){

                        this.status = this.currentStatus();

                        // console.log("----------------");
                        if(this.journey.currentRoute === null){
                            // console.log("ADDING");
                            let route = this.journey.addRouteFromLineString(this.journey.features.current);
                            
                            if (route instanceof RouteRebalancing){
                                // console.log("REBALANCING");
                                this.isRebalancing = true;
                                this.journey.features.increment();
                            }
                        } else {
                            if (this.journey.currentRoute.isActive()) {
                            
                                // console.log(this.journey.currentRoute.toString());

                                let currentCoord = this.journey.getCurrentCoordinate();
                                this.journey.addCoords(currentCoord);

                                if (this.isRebalancing) {
                                    //Updating the line origin when rebalancing
                                    this.journey.plannedRoute.o = currentCoord;
                                }

                                //map.panTo(coordinates[i]);

                                this.journey.updateCurrentCoordinate();

                            } else {
                                // console.log("RESETING");
                                // End processing line, can go to next feature
                                this.journey.features.increment();
                                this.journey.endCurrentRoute();
                                if (this.isRebalancing) {
                                    this.stopRelocating();
                                }
                            }
                    }
                        
                    }
                    finishedJourney(){
                        return this.journey.features.isEmpty();
                    }
                    stopRelocating(){
                        // Remove relocation path and target
                        this.journey.removeRebalancingGuideLine();
                        this.isRebalancing = false;
                    }

                    update(){

                        //console.log("Increment:" + this.journey.features.leg)
                        if (this.journey.features.isPoint()) {
                            this.processNode();
                        } else {
                            this.processRoute();
                        }
                    }
                }

                function getVehicleListFromData(data){
                    
                    fleet = [];

                    for (let vehicle of data["routes"]) {
                        let v = new Vehicle(vehicle["id"], vehicle["path"]);
                        allCoords = v.journey.features.getAllCoordinates()
                        fleet.push(v);
                    }

                    fleet.pop();
                    //fleet.shift();

                    return fleet;

                }
                d3.json(source_gson, function(err, data) {

                    fleet = getVehicleListFromData(data);

                    console.log(fleet);

                    if (err) throw err;
                    
                    // add it to the map
                    map.addSource('routes', { type: 'geojson', data: geojsonRoutes });
                    map.addSource('nodes', { type: 'geojson', data: geojsonNodes });
                    
                    var minLineWidth = 1;
                    var maxLineWidth = 5;

                    var minLineOpacity = 0.1;
                    var maxLineOpacity = 0.5;
                    
                    //TODO what happens when we have target -> target?

                    // Vehicle route
                    map.addLayer({
                        "id": "routes",
                        "type": "line",
                        "source": "routes",
                        "layout": {
                            "line-join": "round",
                            "line-cap": "round"
                            },
                        "paint": {
                        "line-color":
                            [
                                'case',
                                ["==",  ['get', 'to'], "target"], 
                                "#FF0000", "#FF0000"
                            ], 
                            "line-opacity":[
                                'case',
                                ["==",
                                    ['get', 'to'],
                                    "target"
                                ], 
                                minLineOpacity, 
                                [
                                '+', 
                                    ['*',
                                        ['/', 
                                            ['get', 'load'],
                                            ['get', 'capacity']
                                        ],
                                        maxLineOpacity - minLineOpacity
                                    ],
                                    minLineOpacity
                                ]
                            ],
                        "line-width": [
                            'case',
                                ["==",
                                    ['get', 'to'],
                                    "target"
                                ], 
                                maxLineWidth,[
                                    'case',
                                        ["==",
                                            ['get', 'load'],
                                            0
                                        ], 
                                    0, 
                                    [
                                    '+', 
                                        ['*',
                                            ['/', 
                                                ['get', 'number_of_requests'],
                                                ['get', 'capacity']
                                            ],
                                            maxLineWidth-minLineWidth
                                        ],
                                        minLineWidth
                                    ]
                                ]
                            ]
                        }}
                    );

                    var minPointSize = 4;
                    var maxPointSize = 8;
                    var targetCircleRadius = 40;
                    var targetCircleOpacity = 0.3;
                    var targetCircleColor = '#FF0000';

                    var rangePointSize = maxPointSize - minPointSize;
                    var pointStyle = {
                        radius: {
                            origin:10,
                            pickup:minPointSize,
                            destination:maxPointSize,
                            target:targetCircleRadius,
                            stop: 10,
                            middle:maxPointSize
                            },
                        color: {
                            business: {light:"#fcc777", dark:"#f8a51b"},
                            standard: {light:"#bd7cb4", dark:"#a3218e"},
                            lowcost: {light:"#56c4c5", dark:"#00acac"}
                        }
                    };

                    // Layer containing the customer ODs
                    map.addLayer({
                        "id": "nodes",
                        "type": "circle",
                        "source": "nodes",
                        "paint": {
                        "circle-radius": [
                            'match',
                            ['get', 'type'],
                            'origin', pointStyle.radius.origin,
                            'pickup', pointStyle.radius.pickup,
                            'destination', pointStyle.radius.destination,
                            'target', pointStyle.radius.target,
                            'stop', pointStyle.radius.stop,
                            'middle', pointStyle.radius.middle,
                            /* other */ 6
                        ],
                        'circle-opacity': [
                            'match',
                            ['get', 'type'],
                            'target', targetCircleOpacity,
                            'pickup', 1,
                            'destination',0.5,
                            /* other */ 0.5],
                        'circle-color': [
                            'match',
                            ['get', 'type'],
                            'origin', '#FFFFFF',
                            'pickup',  [
                                'match',
                                ['get', 'user_class'],
                                'A', pointStyle.color.business.dark,
                                'B', pointStyle.color.standard.dark,
                                'C', pointStyle.color.lowcost.dark,
                                /* other */ '#00ff00'],
                            'destination', [
                                'match',
                                ['get', 'user_class'],
                                'A', pointStyle.color.business.dark,
                                'B', pointStyle.color.standard.dark,
                                'C', pointStyle.color.lowcost.dark,
                                /* other */ '#00ff00'],
                            'target', targetCircleColor,
                            'stop', '#FF0000',
                            'middle', '#FF0000',
                            /* other */ '#ccc'
                        ]
                        }
                    });

                    for(i=0;i<fleet.length;i++){
                        let v = fleet[i];
                        let f = {
                            "type": "Feature",
                            "properties": { "id": i, "status": "rebalancing" },
                            "geometry": {
                                "type": "Point",
                                "coordinates": v.origin.coordinates
                            }
                        };
                        geojsonVehicles.features.push(f);
                    }

                    // add it to the map
                    map.addSource('point', { type: 'geojson', data: geojsonVehicles});
         
                    // Adding red arrow representing vehicle
                    map.loadImage('img/red_arrow_up_small.png', function(error, image) {
                        if (error) throw error;
                        // sdf allows icon colorization
                        map.addImage('vehicle', image,  { 'sdf': true });
                        map.addLayer({
                            "id": "point",
                            "type": "symbol",
                            "source":  "point",
                            "layout": {
                                "icon-image": "vehicle",
                                "icon-size": 1,
                                "icon-rotate": ["get", "bearing"],
                                "icon-rotation-alignment": "map",
                                "icon-allow-overlap": true,
                                "icon-ignore-placement": true
                            },
                            'paint': {
                                'icon-color': [
                                    'match', // Use the 'match' expression: https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions-match
                                    ['get', 'status'], // Use the result 'STORE_TYPE' property
                                    'rebalancing',  '#e31a1c',
                                    'cruising', '#225ea8',
                                    'idle', '#081d58',
                                    'carrying1', '#1d91c0',
                                    'carrying2', '#7fcdbb',
                                    'carrying3', '#c7e9b4',
                                    'carrying4', '#ffffd9',
                                    '#FFFFFF' // any other store type
                                ]
                            }
                        });
                    });

                    // Change the cursor to a pointer when the mouse is over the nodes layer
                    map.on('mouseenter', 'nodes', function () {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    
                    // Change it back to a pointer when it leaves
                    map.on('mouseleave', 'nodes', function () {
                        map.getCanvas().style.cursor = '';
                    });


                    function addNodePopToMap(e){
                        var features = map.queryRenderedFeatures(e.point, {
                            layers: ['nodes'] // replace this with the name of the layer
                        });

                        if (!features.length) {
                            return;
                        }

                        var feature = features[0];

                        var node = new NodeFactory(feature);

                        var popup = new mapboxgl.Popup({ offset: [0, -15] })
                            .setLngLat(feature.geometry.coordinates)
                            .setHTML(node.popup)
                            .addTo(map);
                    }

                    map.on('click', addNodePopToMap);

                    // setup the viewport
                    map.jumpTo({ 'center': fleet[0].origin.coordinates, 'zoom': 13 });
                    map.setPitch(30);
                    
                    var msInterval = 1; // speed / acceleration;
                    var timer = window.setInterval(updateFleetProgress, msInterval);
                    
                    /*
                    fleetPos = {
                        0: {
                            "bearing":[],
                            "coordinate":[],
                            "steps":0,
                            "count":0
                        }
                    }

                    function preProcessData() {
                        let allVehiclesProcessed = true;
                        //console.log("#Fleet status");

                        let traveledLineString = [];
                        let visitedPoints = [];


                        for (i = 0; i < fleet.length; i++) {
                            let v = fleet[i];

                            if (!v.finishedJourney()) {

                                allVehiclesProcessed = false;

                                v.update();

                                Array.prototype.push.apply(traveledLineString, v.journey.traveledLineString);
                                Array.prototype.push.apply(visitedPoints, v.journey.visitedPoints);

                                // Add planned routes (e.g., rebalancing guideline and target)
                                Array.prototype.push.apply(traveledLineString, v.journey.plannedLineString);
                                Array.prototype.push.apply(visitedPoints, v.journey.plannedPoints);

                                fleetPos[i]["bearing"].push(v.bearing);
                                fleetPos[i]["coordinate"].push(v.currentCoordinate);
                                fleetPos[i]["steps"]++;   
                            }
                        }
                        return allVehiclesProcessed;
                    }

                    
                    finished = false;
                    while (!finished){
                        finished = preProcessData();
                    }

                    if (finished){
                        for (i = 0; i < fleet.length; i++) {
                            let v = fleet[i];
                            console.log(v.toString() + "==" + v.journey.features.toString());
                        }

                        console.log("Finished pre-processing...");
                        var timerPlay = window.setInterval(play, msInterval);
                    }

                    function play(){
                        let allVehiclesProcessed = true;
                        //console.log("#Fleet status");

                        let traveledLineString = [];
                        let visitedPoints = [];


                        for (i = 0; i < fleet.length; i++) {
                            let v = fleet[i];
                            console.log(fleetPos[i]["count"] + "<" + fleetPos[i]["steps"]);

                            if (fleetPos[i]["count"] <= fleetPos[i]["steps"]) {

                                geojsonVehicles.features[i].properties.bearing = fleetPos[i]["bearing"][fleetPos[i]["count"]];
                                geojsonVehicles.features[i].geometry.coordinates = fleetPos[i]["coordinate"][fleetPos[i]["count"]];

                                fleetPos[i]["count"]++;
                                allVehiclesProcessed = false;
                                
                                stepA = v.journey.stepTraveledLineString[fleetPos[i]["count"] - 1];
                                stepB = v.journey.stepTraveledLineString[fleetPos[i]["count"]];

                                traveledLineString = v.journey.traveledLineString[0];
                                
                                traveledLineString.geometry.coordinates = v.journey.coords.slice(0, fleetPos[i]["count"]);
                                //Array.prototype.push.apply(visitedPoints, v.journey.visitedPoints);

                                // Add planned routes (e.g., rebalancing guideline and target)
                                //Array.prototype.push.apply(traveledLineString, v.journey.plannedLineString);
                                //Array.prototype.push.apply(visitedPoints, v.journey.plannedPoints);

                                
                            }
                        }

                        if (allVehiclesProcessed) {
                            window.clearInterval(timerPlay);
                        } else {
                            geojsonRoutes.features = traveledLineString;
                            //geojsonNodes.features = visitedPoints;
                            map.getSource('routes').setData(geojsonRoutes);
                            //map.getSource('nodes').setData(geojsonNodes);
                            map.getSource('point').setData(geojsonVehicles);
                        }
                    }
                    */

                    function updateFleetProgress() {
                        let allVehiclesProcessed = true;
                        //console.log("#Fleet status");

                        let traveledLineString = [];
                        let visitedPoints = [];

                        
                        for (i=0; i < fleet.length;i++) {
                            let v = fleet[i];

                            if (!v.finishedJourney()) {
                                //console.log(v.toString() + "==" + v.journey.features.toString())
                                v.update();
                                allVehiclesProcessed = false;
                            }

                            // Add paths and nodes for all vehicles (finished and unfinished)
                            Array.prototype.push.apply(traveledLineString, v.journey.traveledLineString);
                            Array.prototype.push.apply(visitedPoints, v.journey.visitedPoints);

                            // Add planned routes (e.g., rebalancing guideline and target)
                            Array.prototype.push.apply(traveledLineString, v.journey.plannedLineString);
                            Array.prototype.push.apply(visitedPoints, v.journey.plannedPoints);

                            geojsonVehicles.features[i].properties.bearing = v.bearing;
                            geojsonVehicles.features[i].properties.status = v.status;
                            geojsonVehicles.features[i].geometry.coordinates = v.journey.currentCoordinate;

                            }

                        // Update map features                        
                        geojsonRoutes.features = traveledLineString;
                        geojsonNodes.features = visitedPoints;
                        map.getSource('routes').setData(geojsonRoutes);
                        map.getSource('nodes').setData(geojsonNodes);
                        map.getSource('point').setData(geojsonVehicles);
                        
                        if (allVehiclesProcessed) {
                            window.clearInterval(timer);
                        }

                    }
                
                

                    d3.select("#customRange1").on("click", function () {
                        let value = document.getElementById("customRange1").value;
                        console.log("SLIDER", value);
                    });
                

            var toggleableLayerIds = [ 'routes', 'nodes', 'point'];
            
            for (var i = 0; i < toggleableLayerIds.length; i++) {
                var id = toggleableLayerIds[i];

                var link = document.createElement('a');
                link.href = '#';
                link.className = 'active';
                link.textContent = id;
                
                link.onclick = function (e) {
                    var clickedLayer = this.textContent;
                    e.preventDefault();
                    e.stopPropagation();
                    
                    var visibility = map.getLayoutProperty(clickedLayer, 'visibility');
                    
                    if (visibility === 'visible') {
                        map.setLayoutProperty(clickedLayer, 'visibility', 'none');
                        this.className = '';
                    } else {
                        this.className = 'active';
                        map.setLayoutProperty(clickedLayer, 'visibility', 'visible');
                    }
                };
                
                var layers = document.getElementById('menu');
                layers.appendChild(link);
            }
            });
        });

        </script>
    
    </body>
</html>